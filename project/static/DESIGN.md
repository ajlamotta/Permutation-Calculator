Python:
I used Flask and Python in app.py to do all of the calculations with permutations necessary for this website to function. First, I created two important classes: Cycles and Permutations. Cycles have attributes corresponding to the cycled numbers and the set they come from. They also come with methods that display the cycle as a string in cycle notation, calculate the length of the cycle, and convert the cycle to a map (dictionary). The Permutation class gives all the relevant infromation needed to a describe a permutation. Its attributes are the constituent cycles in its decomposition, the elements they come from (which could technically be calculated by looking at the cycles, but it's more efficient to pass it as an attribute), and whether or not fixed points will be hidden when displaying this permutation. Permutations have the following methods: they can display the cycle decomposition in a string, output a (dictionary) map representing the permutation, compute the lengths of its constituent cycles, compute the order of the permutation, compute the sign of the permutation, compute the number of cycles in the permutation, compute the number of inversions, raise the permutation to the nth power, calculate the inverse of the permutation (this wasn't used in the website but could be), and compute the fixed points and permuted (i.e. not fixed) points.

There are also supplementary functions needed to do all of the calculations. For one, there is a function that computes the cycle decomposition of a given map representing a permutation (storing it as a Permutation object). Note that we declared Permutation objects to be understood in terms of their cycle decompositions, which is why this function is so important. This decision was made because the cycle decomposition of a permutation reveals a lot of important information about the permutation. The cycle_decomp function uses find_cycle as an auxiliary function to find cycles within the mapping passed to cycle_decomp. These two functions together are implemented via the classic cycle decomposition algorithm important in mathematics. There is also a function which multiplies (i.e. composes) a list of maps, and it does so right to left or left to right depending on an argument. We then have a function which converts the user inputed text to a list of maps that can be multiplied. It does this by traversing the string left to right and looking for cycles, one-line notation, or exponents. string_to_maps uses the auxiliary functions cycle_string_to_map and one_line_string_to_map to convert a string representing a permutation into a map. A function string_to_perm then uses string_to_maps to calculate a permutation representing the product of the permutations appearing in the string entered by the user.

The last three functions are digits, identity, and duplicates. Duplicates checks for duplicates in a list, and this function is used to check if a string representing a cycle is valid when entered by the user (since a cycle cannot have duplicate numbers appearing in it). digits and identity are used to avoid repetition when talking about the set of elements the permutation acts on. I found it easiest and most efficient to keep track of the elements of the set by relying only on the value of N, a parameter representing the size of the set being permutated; at one point, for instance, I was relying on both N and digits, which got redundant and made code longer than it needed to be. digits(N) outputs the list 1,2,...,N, and identity(N) outputs as a (dictionary) map the identity function on digits(N). In addition to N, the other important parameters include hide_fp, which keeps track of whether fixed points should be hidden, right_to_left, which keeps track of whether permutations should be multiplied right to left or left to right, and the string s that is entered by the user. These parameters are all obtained from the webpage and used to calculate the permutation that is displayed. At one point I had some of them as global variables, but this was very annoying and buggy to work with, so I converted them to local variables that could be passed as parameters into the various functions in app.py.

The actual application is ran using Flask, which manages the webpage. When index.html is ran, the program first keeps track of the parameters inputed by the user, namely N, right_to_left, hide_fp, and s. Then, string_to_perm is called to calculate the permutation perm resulting from the user's input. If any issue occurs during this process (i.e an input is not entered correctly by the user), a variable valid_input is changed to False (default is True) and an error message is rendered on the webpage. If things go as planned, the webpage renders using perm and the values of the paramters. Actually, to keep everything on a single HTML page, I just had valid_input be passed as a parameter too and used Jinja to determine whether or not the page will show an error message based on valid_input.

HTML/CSS:
index.html and styles.css format a webpage to get user input and display all my information. I imported some Javascript code from MathJax to render LaTeX on my website, which I used to display the two-line notation of a permutation via a matrix. Also in the head is a bit of Javascript that effectively waits until everything is loaded before displaying the code. It does this via opacity, and the reason is that otherwise the website will show some LaTeX code for a split second before it is rendered as a matrix, which looks ugly. I then have an element which explains how the user is to enter in what will be calculated. Following that is a form. There is a "number" input to keep track of N, two checkboxes to keep track of hide_fp and right_to_left, a "text" input for where the user enters in the product of permutations to be calculated, and a submit button. I used Jinja to display as a default the previous value entered, and within my Python code, there is no differentation between a GET and POST method. This is because it doesn't matter whether information is displayed in the URL bar, and it's most user-friendly for reloading and calculating to not change the values of entered parameters back to default in case the user wants to make slight changes to these parameters. Finally, Jinja (especially the variable perm) is used to display all of the relevant information about the permutation calculated from the user's input. 

Extra:
There is one feature which I would really like to have added given more time. I was able to get started on it, and the commented code can be found in index.html. Namely, I would like to display a permutation diagram, which is a nice visualization of a permutation via explicitly writing out the input and output sets on two lines (i.e. 1,2,...,N) and then connecting numbers from the top set (inputs) to the bottom (outputs) via arrows. Unfortunately, I did not get the time to implement this feature, but I figure it was worth mentioning. After submission of this project, I plan to add this feature and anticipate it only taking a few extra hours or so.